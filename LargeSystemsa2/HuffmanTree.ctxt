#BlueJ class context
comment0.params=input\ output
comment0.target=HuffmanTree(java.io.File,\ java.io.File)
comment0.text=\n\ Constructor\:\ files\n\ Uses\ input\ and\ output\ files\ to\ construct\ the\ huffman\ tree.\ \n\ @param\ input\ The\ input\ file\ to\ be\ compressed\n\ @param\ output\ The\ output\ file\ to\ be\ written\ to\ in\ Huffman\ encoding\n\ @throws\ IOException\n\ \n
comment1.params=input\ output
comment1.target=HuffmanTree(java.lang.String,\ java.lang.String)
comment1.text=\n\ Constructor\:\ String\n\ Uses\ the\ supplied\ strings\ to\ access\ the\ relevant\ files\ and\ calls\ the\ file\ constructor.\ \n\ Therefore,\ all\ critical\ functions\ should\ be\ supplied\ there.\ \n\ @param\ input\ The\ string\ representation\ of\ the\ input\ file,\ including\ path\n\ @param\ output\ The\ string\ representation\ of\ the\ output\ file,\ including\ path\n\ @throws\ IOException\n
comment10.params=in\ map
comment10.target=java.lang.String\ transcode(java.io.File,\ java.util.Map)
comment10.text=\n\ transcode\n\ Takes\ an\ input\ stream\ and\ produces\ a\ string\ arranged\ as\ a\ set\ of\ bytes\ with\ the\ equivalent\ huffman\ Mapping.\ \n\ Requires\ that\ a\ huffman\ mapping\ already\ exists.\ \n\ \n\ Because\ of\ it's\ reliace\ upon\ Strings,\ it\ is\ very\ vulnerable\ to\ problems\ with\ string\ concatenation.\n\ To\ circumvent\ this\ problem,\ a\ StringBuffer\ allows\ for\ far\ greater\ performance.\ \n
comment11.params=l\ r
comment11.target=HuffmanTree.HuffNode\ branch(HuffmanTree.HuffNode,\ HuffmanTree.HuffNode)
comment11.text=\n\ branch\n\ Takes\ two\ nodes\ and\ connects\ them\ via\ a\ branch\ that\ has\ the\ frequency\ of\ the\ sum\ of\ the\ two\n\ Nodes\ below.\ Note\ byte\ value\ is\ zero.\ \n
comment12.params=m
comment12.target=java.util.List\ getFreqDistList(java.util.Map)
comment12.text=\n\ getFreqDistList\n\ Returns\ the\ mapping\ of\ values\ and\ their\ frequencies\ as\ a\ List.\ \n
comment13.params=
comment13.target=java.lang.String\ printByteFreq()
comment13.text=\n\ printByteFreq\n\ A\ simple\ method\ to\ illustrate\ the\ byte\ frequency\ in\ the\ read\ file.\ Used\ for\ debugging.\n
comment14.params=l
comment14.target=PriorityQueue\ createQueue(java.util.List)
comment14.text=\n\ createQueue\n\ Takes\ a\ list\ of\ characters\ and\ their\ frequency\ distribution\ as\ HuffNodes\n\ and\ places\ them\ in\ the\ priority\ queue\ according\ to\ there\ distribution\n\ frequency.\ Intended\ to\ have\ it\ such\ that\ characters\ with\ the\ higher\n\ distribution\ frequency\ will\ have\ higher\ priority\ in\ the\ queue.\ \n\ \n\ Note\ that\ it\ is\ assumed\ that\ this\ will\ enqueue\ HuffNodes,\ it\ cannot\ \n\ use\ another\ data\ type.\ It\ is\ assumed\ that\ this\ method\ will\ decode\ the\ \n\ 2\ unit\ array\ produced\ elsewhere.\ \n\ \n\ Returns\ a\ priority\ queue.\n\ \n\ @param\ l\ The\ Orderedlist\ of\ elements\n
comment15.params=readFile
comment15.target=java.util.Map\ freqDist(java.io.InputStream)
comment15.text=\n\ freqDist\n\ returns\ a\ frequency\ distribution\ for\ the\ bytes\ for\ the\ file.\ \n\ each\ element\ of\ the\ Map\ is\ a\ size\ 2\ array,\ first\ with\ the\ byte\n\ and\ then\ followed\ by\ the\ frequency.\ \n\ \n\ thus\:\n\ \n\ Map\:\n\ \ |\ [a][3]\n\ \ |\ [b][1]\n\ \ |\ [c][4]\n\ \ \n\ \ indicates\ 'a'\ is\ found\ 3\ times,\ b\ found\ once\ etc.\ \n\ \ \n\ \ To\ do\ this,\ it\ uses\ a\ hashmap,\ increasing\ the\ counter\ of\ each\ byte\ as\ found.\ \n
comment16.params=
comment16.target=java.util.Map\ huffmanCodingMap()
comment16.text=\n\ huffmanCodingMap\n\ Uses\ the\ codes\ generated\ to\ create\ a\ map\ of\ byes.\ Uses\ the\ genCodes()\ method\n\ to\ create\ an\ array\ and\ then\ stores\ returns\ the\ following\ as\ a\ map\ with\ the\ \n\ byte\ value\ as\ the\ key\ and\ the\ mapping\ object\ the\ huffman\ code.\ \n\ \n\ Note\ that\ that\ for\ every\ entry\ in\ genCodes();\n\ [0]\ -\ byte\ value\n\ [1]\ -\ Huffman\ code\n
comment17.params=
comment17.target=java.util.Vector\ genCodes()
comment17.text=\n\ genCodes\n\ Starts\ the\ code\ genearation\ method\n
comment18.params=h\ path
comment18.target=java.util.Vector\ genCodes(HuffmanTree.HuffNode,\ java.lang.String)
comment18.text=\n\ genCodes\n\ Generates\ the\ huffmoan\ codes\ by\ tranversing\ the\ tree.\ \n\ Returns\ codes\ as\ an\ array\ int\ the\ following\ format\:\n\ Stored\ as\ an\ array\ within\ a\ vector.\n\ \n\ Vector\:\n\ |\ [ByteValue]\ [Code]\ \n\ |\ [ByteValue]\ [Code]\ \n
comment19.params=
comment19.target=java.util.Map\ getMap()
comment19.text=\n\ getMap\n\ Provides\ a\ map\ of\ the\ data\n
comment2.params=v
comment2.target=java.lang.String\ printMappings(java.util.Vector)
comment2.text=\n\ printMappings\n\ Prints\ the\ current\ mappings\ to\ screen.\ \n\ @param\ v\ The\ input\ vector\ which\ will\ be\ printed\ out.\ Intended\ to\ be\ the\ Huffman\ encoding\ and\ \n\ associated\ byte\ value.\ \n
comment3.params=
comment3.target=java.lang.String\ toString()
comment3.text=\n\ toString\n\ Prints\ the\ mappings\ to\ a\ string.\n
comment4.params=stream
comment4.target=void\ init(java.io.InputStream)
comment4.text=\n\ init\n\ The\ actual\ constructing\ method\ that\ is\ called\ by\ either\ of\ the\ constructors.\ \n\ Performs\ the\ operations\ to\ create\ the\ HuffmanTree.\ \n\ @param\ stream\ The\ file\ input\ stream\ with\ which\ to\ encode\n
comment5.params=
comment5.target=void\ fileOutput()
comment5.text=\n\ fileOutput\ -\ local\n\ The\ fileOutput\ being\ performed\ on\ the\ local\ variables.\ Essentially\ just\ directs\n\ the\ writeout\ methods\ to\ the\ specified\ local\ variables.\ \n
comment6.params=input\ output
comment6.target=void\ fileOutput(java.io.File,\ java.io.File)
comment6.text=\n\ fileOutput\n\ Takes\ the\ output\ file\ and\ transcodes\ the\ input\ file\ with\ the\ help\ of\ the\ huffman\ coding.\n\ @param\ input\ the\ file\ being\ read\ in\ to\ be\ transcoded\ to\ String\n\ @parm\ output\ the\ file\ being\ written\ to\n
comment7.params=in
comment7.target=byte[]\ stringToBytes(java.lang.String)
comment7.text=\n\ stringToBytes\n\ Transforms\ the\ string\ to\ a\ byte\ array\ suitable\ for\ writing\ to\ a\ file.\ The\ algorithm\ itself\ is\ relatively\ simple,\n\ but\ relies\ upon\ Strings\ -\ particularly\ in\ the\ transcode\ method.\ It\ has\ not\ been\ sufficiently\ optimised\ to\n\ achieve\ much\ in\ the\ way\ of\ performance.\ \n\ \n\ @param\ in\ The\ string\ input\ to\ be\ transformed\n
comment8.params=in
comment8.target=byte\ constructByte(java.lang.String)
comment8.text=\n\ constructByte\n\ Takes\ a\ string\ of\ 8\ characters\ long\ and\ constructs\ a\ byte\ out\ of\ it.\ \n\ @param\ in\ The\ string\ of\ 8\ bits.\ Can\ be\ less.\ \n
comment9.params=
comment9.target=void\ outputString()
comment9.text=\n\ outputString\n\ The\ transcode\ method\ being\ performed\ on\ the\ object\ variables\n
numComments=20
